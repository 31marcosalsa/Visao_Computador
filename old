import numpy as np
import cv2 as cv
"""
# Variáveis e função auxiliar
MIN_CONTOUR_AREA = 100
RESIZED_IMAGE_WIDTH = 20
RESIZED_IMAGE_HEIGHT = 30

font = cv.FONT_HERSHEY_SIMPLEX


# Mostra no terminal a posição (x,y) do click do rato
def showMousePos(event, x, y, flags, param):
    if event == cv.EVENT_LBUTTONDOWN:
        print("X -> " + str(x) + ", Y -> " + str(y))


# Início do programa
def main():
    imageInput = "im4.png"
    imageName = imageInput.partition(".")[0]

    # Ler ficheiro das classificações
    try:
        npaClassifications = np.loadtxt(imageName + "_classifications.txt", np.float32)
    except:
        blankImage = np.zeros((200, 500, 3), np.uint8)
        cv.putText(blankImage, 'Classificador Dos Contornos', (23, 100), font, 1, (0, 0, 255), 2, cv.LINE_AA)
        cv.putText(blankImage, 'Nao Lido', (185, 150), font, 1, (0, 0, 255), 2, cv.LINE_AA)
        cv.imshow("Erro", blankImage)
        cv.waitKey(0)
        cv.destroyAllWindows()
        return

    # Ler ficheiro das imagens geradas no treino
    try:
        npaFlattenedImages = np.loadtxt(imageName + "_flattened_images.txt", np.float32)
    except:
        blankImage = np.zeros((200, 500, 3), np.uint8)
        cv.putText(blankImage, 'Contornos Gerados ', (93, 100), font, 1, (0, 0, 255), 2, cv.LINE_AA)
        cv.putText(blankImage, 'Nao Lidos', (165, 150), font, 1, (0, 0, 255), 2, cv.LINE_AA)
        cv.imshow("Erro", blankImage)
        cv.waitKey(0)
        cv.destroyAllWindows()
        return

    # Ler imagem teste
    testImage = cv.imread(imageInput)

    # print(npaClassifications) [ 99.  97.  65.  49.  68.  66.  67.  51. 100.  98.]
    # A função kNearest.train recebe um array 1d
    npaClassifications = npaClassifications.reshape((npaClassifications.size, 1))

    # print(npaClassifications)v[[ 99.]
    #                            [ 97.]]

    kNearest = cv.ml.KNearest_create()

    kNearest.train(npaFlattenedImages, cv.ml.ROW_SAMPLE, npaClassifications)

    # Operações morfológicas na imagem de teste
    # Greyscale
    greyImage = cv.cvtColor(testImage, cv.COLOR_BGR2GRAY)
    cv.imwrite(imageName + "_test" + "_greyscale.png", greyImage)
    cv.imshow(imageName + "_greyscale", greyImage)

    # Blur
    blurImage = cv.GaussianBlur(greyImage, (5, 5), 0)
    cv.imwrite(imageName + "_test" + "_blur.png", blurImage)
    # cv.imshow(imageName + "_blur", blurImage)

    # Threshold
    thresholdImage = cv.adaptiveThreshold(blurImage, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2)
    cv.imwrite(imageName + "_test" + "_threshold.png", thresholdImage)
    cv.imshow(imageName + "_threshold", thresholdImage)

    # Dilatation
    dilatedImage = cv.dilate(thresholdImage, (5, 5), iterations=5)
    cv.imwrite(imageName + "_test" + "_dilatation.png", dilatedImage)
    cv.imshow(imageName + "_dilated", dilatedImage)

    # Criar cópia da imagem com threshold e dilatada porque findContours modifica a imagem
    threshDilatedImage = dilatedImage.copy()

    # Encontrar contornos das letras
    contourImage, contourArray, contourHierarchy = cv.findContours(threshDilatedImage, cv.RETR_EXTERNAL,
                                                                   cv.CHAIN_APPROX_SIMPLE)
    cv.imwrite(imageName + "_test" + "_contours.png", contourImage)
    cv.imshow(imageName + "_contours", contourImage)


    # Preencher array com coordenadas dos retângulos que abrangem os contornos das letras
    boundRectArray = []
    for p in range(0, len(contourArray)):
        if cv.contourArea(contourArray[p]) > MIN_CONTOUR_AREA:
            boundRectArray.append(cv.boundingRect(contourArray[p]))


    # Ordenar o boundRectArray com as letras da esquerda para a direita
    for passnum in range(len(boundRectArray) - 1, 0, -1):
        for i in range(passnum):
            if boundRectArray[i][0] > boundRectArray[i + 1][0]:
                tmp = boundRectArray[i]
                boundRectArray[i] = boundRectArray[i + 1]
                boundRectArray[i + 1] = tmp


    # Juntar o bound rectangle dos acentos ao das letras (no caso do u)
    posRemoveRect = []
    for i in range(0, len(boundRectArray) - 1):
        nextBottomRightY = boundRectArray[i + 1][1] + boundRectArray[i + 1][3]
        currentTopLeftY = boundRectArray[i][1]

        if nextBottomRightY > currentTopLeftY and nextBottomRightY - currentTopLeftY < 4:
            nextTopLeftY = boundRectArray[i + 1][1]
            offsetY = currentTopLeftY - nextTopLeftY

            lst = list(boundRectArray[i])
            lst[1] = nextTopLeftY
            lst[3] = lst[3] + offsetY
            boundRectArray[i] = tuple(lst)

            posRemoveRect.append(i + 1)


    # Limpar o array dos retângulos de ruído
    cleanBRA = []
    for i in range(0, len(boundRectArray)):
        if i not in posRemoveRect:
            cleanBRA.append(boundRectArray[i])


    # Preparar o array para leitura topLeft - bottomRight
    # Ordenar as letras por linha
    cleanBRA = sorted(cleanBRA, key=itemgetter(1))


    # Ordenar as letras na mesma linha
    for passnum in range(0, len(cleanBRA)):
        for i in range(passnum):
            currentTopLeftX = cleanBRA[i][0]
            currentTopLeftY = cleanBRA[i][1]
            nextTopLeftX = cleanBRA[i + 1][0]
            nextTopLeftY = cleanBRA[i + 1][1]

            if abs(currentTopLeftY - nextTopLeftY) < 31 and currentTopLeftX > nextTopLeftX:
                tmp = cleanBRA[i]
                cleanBRA[i] = cleanBRA[i + 1]
                cleanBRA[i + 1] = tmp

    # print(cleanBRA)


    # Encontrar posições onde meter espaços e descobrir mudanças de linha
    spacePos = []
    newlinePos = []
    for i in range(0, len(cleanBRA) - 1):
        currentTopLeftX = cleanBRA[i][0]
        currentBottomRightX = cleanBRA[i][0] + cleanBRA[i][2]
        nextTopLeftX = cleanBRA[i + 1][0]

        if nextTopLeftX - currentBottomRightX > 20 and i + 1 not in spacePos:
            spacePos.append(i+1)

        if currentTopLeftX > nextTopLeftX:
            newlinePos.append(i+1)

    print("\nEspaços encontrados nas posições: " + str(spacePos))
    print("\nMudanças de linha encontradas nas posições: " + str(newlinePos))


    # Avaliar cada letra identificada e desenhar retângulo
    phrasePos = 0
    resultString = ""
    for contourRect in cleanBRA:
        topLeftX = contourRect[0]
        topLeftY = contourRect[1]
        rectW = contourRect[2]
        rectH = contourRect[3]
        bottomRightX = topLeftX + rectW
        bottomRightY = topLeftY + rectH

        cv.rectangle(testImage, (topLeftX, topLeftY), (bottomRightX, bottomRightY), (0, 255, 0), 2)

        imageROI = thresholdImage[topLeftY: bottomRightY, topLeftX: bottomRightX]
        imageROIResized = cv.resize(imageROI, (RESIZED_IMAGE_WIDTH, RESIZED_IMAGE_HEIGHT))

        # A função kNearest.findNearest recebe um array
        imageROIResArray = np.float32(imageROIResized.reshape((1, RESIZED_IMAGE_WIDTH * RESIZED_IMAGE_HEIGHT)))

        retval, npaResults, neigh_resp, dists = kNearest.findNearest(imageROIResArray, k=1)
        resultChar = chr(int(npaResults[0][0]))

        # Inserir espaços se necessário
        if phrasePos in spacePos:
            resultString += " " + resultChar

        elif phrasePos in newlinePos:
            resultString += "\n              " + resultChar
        else:
            resultString += resultChar

        phrasePos += 1


    # Mostrar Resultado Final
    print("\n" + "Texto Lido:   " + resultString + " \n")

    cv.imshow(imageInput, testImage)
    cv.setMouseCallback(imageInput, showMousePos)
    cv.waitKey(0)
    cv.destroyAllWindows()

    return
"""
